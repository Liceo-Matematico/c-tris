# -*- coding: utf-8 -*-
"""3dTris.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dasuiJGGSWXfRBATQEvQUI_e4kxRsO5k

***3dTris*** is a game like *Tic-Tac_Toe* or *Noughts and Crosses* in which the player has a symbol and, in order to win, has to realise, under certain rules that we will define, a triple of her symbol alog a row or a colum or a dyagonal of a three by three board.
In the standard *Nougths and Crosses* symbols are placed on the bord at each turn by the players, in ***3dTris***, players have to fill the board with symbols $i,j,k$ and $-i,-j,-k$. The symbol
 $i,j,k$ denote respectivelly positively oriented unit vectors along three orthogonal axis. The symbol $-i,-j,-k$ are unit vector negativelly oriented along the same three axis. Card symbols are therefore vectors. When a player places a card on a square of the board the symbol on the card and the symbol on the square are combined according to a symple operation: take the vector present on the player card and compute the vector product with the vector which is on the chosen square of board.
 The fundamental product rules are the following:
 $$i\times i=0$$
 $$i\times j=k$$
 $$i\times k=-j$$
 $$j\times i=-k$$
 $$j\times j=0$$
 $$j\times k=i$$
 $$k\times i=j$$
 $$k\times j=-i$$
 $$k\times k=0$$
 With negatively oriented vectors it sufficient to remember that if $u$ and $v$ are two vectors and $\alpha,\beta$ real numbers then:
 $$\alpha\beta (u\times v)=(\alpha u)\times(\beta v)= (\beta u)\times(\alpha v)$$
 an apply the previous formula for $\beta,\alpha=\pm 1$.
 The rules to play ***3dTris*** are:


1. Extract at random 9 simbols from $i,j,k$ and $-i,-j,-k$ and place them on the 3 by 3 board.
2. Each player extract 1 symbol to define its suit/house.
3. Each player extract 2 cards and in turn places her cards on the bord to obtain a **tris** with  her symbol/vector. Remember that placing a card means to compute a vector product:
$$\mbox{Player vector}\times\mbox{vector on the square}$$
and place the result on the square in the board.

Important observation: there might appear $0$ thatin ***3dTris*** behave as constraint that connot be modified.

$$\Large Enjoy~~3dTris!!!$$

The following cell set up the routine to compute the vector product of bases vectors $i,j,k$ and their opposite $-i,-j,-k$
"""

#!pip install pandas
from IPython.display import display
import random
import pandas as pd

def vector_prod(v1, v2):
    # Define the vector symbols and their corresponding values
    vectors = {
        'i': (1, 0, 0),
        '-i': (-1, 0, 0),
        'j': (0, 1, 0),
        '-j': (0, -1, 0),
        'k': (0, 0, 1),
        '-k': (0, 0, -1),
        '0': (0, 0, 0)
    }

    # Get the vector values for the input arguments
    v1_value = vectors[v1]
    v2_value = vectors[v2]

    # Compute the vector product
    x = v1_value[1] * v2_value[2] - v1_value[2] * v2_value[1]
    y = v1_value[2] * v2_value[0] - v1_value[0] * v2_value[2]
    z = v1_value[0] * v2_value[1] - v1_value[1] * v2_value[0]

    # Determine the output vector based on the computed values
    if x == 0 and y == 0 and z == 0:
        return '0'
    elif x == 1 and y == 0 and z == 0:
        return 'i'
    elif x == -1 and y == 0 and z == 0:
        return '-i'
    elif x == 0 and y == 1 and z == 0:
        return 'j'
    elif x == 0 and y == -1 and z == 0:
        return '-j'
    elif x == 0 and y == 0 and z == 1:
        return 'k'
    elif x == 0 and y == 0 and z == -1:
        return '-k'

# Test the vector_prod function
#print(vector_prod('i', 'i'))       # Output: 0
#print(vector_prod('i', '-i'))      # Output: 0
#print(vector_prod('i', 'j'))       # Output: k
#print(vector_prod('i', 'k'))       # Output: -j
#print(vector_prod('-i', 'i'))      # Output: 0
#print(vector_prod('-i', 'j'))      # Output: -k
#print(vector_prod('-i', 'k'))      # Output: j

#print(vector_prod('j', 'j'))       # Output: 0
#print(vector_prod('j', '-j'))      # Output: 0
#print(vector_prod('j', 'i'))       # Output: -k
#print(vector_prod('j', 'k'))       # Output: i
#print(vector_prod('-j', 'j'))      # Output: 0
#print(vector_prod('-j', 'i'))      # Output: k
#print(vector_prod('-j', 'k'))      # Output: -i

#print(vector_prod('k', 'k'))       # Output: 0
#print(vector_prod('k', '-k'))      # Output: 0
#print(vector_prod('k', 'j'))       # Output: -i
#print(vector_prod('k', 'i'))       # Output: j
#print(vector_prod('-k', 'k'))      # Output: 0
#print(vector_prod('-k', 'j'))      # Output: i
#print(vector_prod('-k', 'i'))      # Output: -j

"""The next cell contains the routine to check for a least a triple (termed *tris*) of the same symbol/card"""

def check_matrix_for_symbol(df, my_symbol):
  # Check rows
  for index, row in df.iterrows():
    if all(element == my_symbol for element in row):
      return True

  # Check columns
  for col in df.columns:
    if all(element == my_symbol for element in df[col]):
      return True

  # Check diagonals
  if all(df.iloc[i, i] == my_symbol for i in range(len(df))):
    return True
  if all(df.iloc[i, len(df) - i - 1] == my_symbol for i in range(len(df))):
    return True

  return False

def modify_df(df):
  print('Here are your vectors...ops...cards again')
  random_vectors=random.choice(vectors)
  print(random_vectors)
  print('and')
  random_vectors=random.choice(vectors)
  print(random_vectors)
  print('Take notes of them, try to get three symbols in line...Dude!')
  # Repeat the function two times
  for _ in range(2):
    card_choice = input("Dude enter your card choice, please: ")
    element_index = input("...and now enter the index of the element you want (e.g., '0,1' for row 0, column 1): ")
    # Split the element index into row and column indices
    row_index, col_index = map(int, element_index.split(','))
    # Access the element from the DataFrame (assuming 'df' is already defined)
    element = df.iloc[row_index, col_index]
    print("Your card choice:", card_choice)
    print("Selected element:", element)
    print("The vector product is then:", vector_prod(card_choice, element))
    print("The previous board was")
    display(df)
    print("\n")
    new_element = vector_prod(card_choice, element)
    df.iloc[row_index, col_index] = new_element
    print("The updated board is")
    display(df)  # Display the updated DataFrame
  return df

"""Run the next cell to start the ***3dTris***"""

print('I shuffle the vectors...ops..the cards for you...Dude')
vectors=['i','-i','j','-j','k','-k']
random_vectors=random.choice(vectors)
matrix = [[random.choice(vectors) for _ in range(3)] for _ in range(3)]
#print(random_vectors)
df = pd.DataFrame(matrix)
display(df)
#check_matrix_for_symbol(df, my_symbol)

my_symbol=random.choice(vectors)
print('Your card suit Dude is:', my_symbol)

while not check_matrix_for_symbol(df, my_symbol):
  df = modify_df(df)

#display(df)
print("Well done Dude! You've got at least one TRIS!!!")
